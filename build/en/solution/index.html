<!doctype html><html lang=en><meta charset=UTF-8><meta content="IE=edge"http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0"name=viewport><link href=/assets/style/base.css rel=stylesheet><link href=/assets/images/logos/Qworum-favicon-16px.png rel=icon><title>Solution • Qworum</title><body><header><nav><ul><li><a aria-label="Return home"href=/en/> <img alt="Qworum logo and name"class="logo logo-light"src=/assets/images/logos/Qworum-logo-and-name.svg> <img alt="Qworum logo and name"class="logo logo-dark"src=/assets/images/logos/Qworum-logo-and-name-dark.svg> </a><li><a href=/en/platform/> Platform </a><li><a class=selected href=/en/solution/> Solution </a><li><a href=/en/plans/> Plans </a><li><a href=/en/developers/> Developers </a><li><a href=/en/about/> About </a></ul></nav></header><main><h1>Category-defining iPaaS and PaaS hybrid solution</h1><p>Qworum offers a technology for modularizing the UI layer of web applications. This module system supports both single-origin and distributed multi-origin applications.<p>In short, Qworum is a platform for composable architectures.<p>And as soon as a module system can support distributed scenarios, it can be used for application integration as well. In other words, in distributed systems, integration and modularisation are two sides of the same coin. And that's why Qworum is both a PaaS and an iPaaS.<figure><img alt="Qworum allows for unbounded nesting levels"src=/assets/images/solution/qworum-ux.svg><figcaption>The user experience of using Qworum applications</figcaption></figure><section id=integrations><h2>The only platform for integrating interactive processes</h2><p>Qworum is the only platform able to support interactive integrations involving complex dependency graphs. As a bonus, Qworum makes API calls 10x easier to implement as compared to other API technologies.<figure><img alt="Building Qworum APIs over REST APIs"src=/assets/images/solution/Qworum-over-REST.svg><figcaption>Building Qworum APIs over REST APIs</figcaption></figure><section id=10x><h3>10x easier integrations</h3><p>Developing applications and services with Qworum is 10x easier than with other technologies such as REST, because:<ul><li>The API caller does not need to authenticate the end-user; each API endpoint takes care of authenticating the user itself if needed.<li>The API caller does not need to obtain an API key, as Qworum API calls are very similar to hyperlinks across websites, which are naturally permissionless.<li>Qworum APIs bring their own UIs, so the UI-related production costs are greatly reduced for the API caller.</ul></section><section id=service-orchestrations><h3>A built-in service orchestration engine</h3><p>Without Qworum, even simple reusable user flows are difficult to implement for web applications, and the main reason for this is the fact that the web was initially conceived as a platform for content, not applications.<p>Here is an example of how hard it is to implement a simple user dialog on the web without Qworum.<p>In a web application, if the user is trying to access his/her account page at <code>/account</code> but hasn't signed in yet, then the user is typically redirected to a path similar to <code>/login?returnTo=/account</code>. But even for a simple login dialog, there are several questions that the current web platform cannot address satisfactorily:<ul><li>What to do when the login does not succeed? Do we redirect to a fixed path such as <code>/</code> (this is the widely used option) or do we specify different paths for different error conditions, such as in <code>/login/?returnTo=/account&returnToIfCancelled=/login-cancelled-by-user&returnToIfTooManyBadPasswords=/suspected-account-hijack</code> ?<li>If the dialog is made of several pages, then do we have to copy the dialog parameters from page to page, in addition to the current dialog state, such as in <code>/login/page-2?username=xyz&returnTo=/account&returnToIfCancelled=/login-cancelled-by-user&returnToIfTooManyBadPasswords=/suspected-account-hijack</code> ? This becomes very unwieldy very quickly.<li>What if the login dialog has to make use of another user dialog such as "Sign in with OpenID Connect" ? Does the login dialog have to send all its parameters to the OIDC dialog, such as in <code>/oidc/?returnTo=/login/oidc-result%3FreturnTo%3D%2Faccount%26amp%3BreturnToIfCancelled%3D%2Flogin-cancelled-by-user%26amp%3BreturnToIfTooManyBadPasswords%3D%2Fsuspected-account-hijack</code> ? (Hint: yes it does.)</ul><p>Qworum elegantly solves these issues by defining a domain-specific language called the <a href=/en/specification/v1/#script>Qworum script</a>, which is used for orchestrating calls to Qworum API endpoints. In Qworum-based applications:<ul><li>User dialogs (i.e. Qworum API endpoints) don't need to know how the application will continue once the dialog has finished running: this is the responsibility of the dialog's caller. And as a result, the dialog does not need to receive any parameters related to return paths. In that, Qworum is very similar to modern runtime environments where a function or an object's method is not concerned about what happens after it has finished executing.<li>URLs only need to contain paths (and possibly fragments), with the dialog parameters conveniently tucked away in the Qworum session states of browser tabs, and available for reading/writing from Qworum scripts as well as from in-page JavaScript.</ul></section><section id=user-authentication><h3>Support for complex service dependency graphs</h3><p>The simple fact of the matter is, without Qworum, the integration of interactive processes involving deep dependencies between applications and services is a technical impossibility.<p>For example, in the architecture outlined below, how does <code>Application 1</code> authenticate the end-user for <code>Service 2</code> and <code>Service 3</code>?<figure><img alt="Qworum allows for unbounded nesting levels"src=/assets/images/solution/user-authentication.svg><figcaption>Qworum can handle user authentication in deep dependency graphs</figcaption></figure><p>In real-world settings such multi-tier integration scenarios will appear more and more often as new specialised SaaS offerings come online. Here is a plausible example:<ul><li>Application 1: A project management application such as Airtable, Monday.com, Zoho or Jira.<li>Service 2: An artifact management service such as Confluence, Basecamp or SharePoint.<li>Service 3: A messaging service such as Slack, Matrix or Microsoft Teams.</ul><p>Let's see what would happen without Qworum:<ul><li>Authenticating the user for <code>Service 2</code> is possible (because <code>Application 1</code> knows that <code>Service 2</code> must be used), although authenticating the user for a 3rd-party service is an overhead that is best avoided. But even for <code>Service 2</code> there is already a security problem, because now <code>Application 1</code> can now impersonate the end-user on <code>Service 2</code>!<li>It is fair to say that authenticating the user for <code>Service 3</code> is a technical impossibility. Indeed, <code>Application 1</code> doesn't even know that <code>Service 2</code> is using <code>Service 3</code> behind the scenes, not to mention all the conversation-tunnelling that must happen between the authenticating service and the end-user.</ul><p>For these reasons, today's composable architectures such as the MACH architecture only support one-level deep dependency trees, and they put on the main client application the burden of building all the UIs for all involved services.<p>With Qworum all these limitations are removed:<ul><li>Each applications/service has direct access to the end-user and so can take care of authenticating their own end-users.<li>Qworum preserves the confidentiality of user authentication information for all involved services.<li>Qworum makes user-authentication a non-issue for all possible dependency-graph topologies.</ul></section></section><section id=ui-bottleneck><h2>A platform for distributed web applications</h2><p>Qworum is the only platform that can support web applications that span multiple websites.<section><h3>What are microservices architectures?</h3><p>Microservices architectures enable rapid software delivery by allowing different parts of a software system to be developed, deployed and updated in parallel by different teams within an organization and also across organizations.<p>Microservices architectures organise developer teams around vertical slices of software systems rather than the horizontal UI, business logic, and data layers. In order words, microservice teams are responsible for all of these 3 layers within the boundaries of a particular slice.</section><section><h3>What is wrong with monolithic user interfaces?</h3><p>For microservices architectures, having a monolithic component at the UI layer represents a bottleneck for the software development lifecycle, because the team responsible for the UI monolith cannot scale with the number of microservices.<h3>Are micro frontends the right solution?</h3><p>Today, the only solution that software developers have at their disposal for breaking UI monoliths into smaller parts involves micro frontends.<p>Micro frontends are UI components that are plugged into dashboard-style web pages for building web applications. In this case web applications become simple containers for micro frontends.<p>Micro frontends are implemented using various technologies such as <a href=https://reactjs.org/docs/components-and-props.html target=_blank>React.js components</a>, <a href=https://developer.mozilla.org/en-US/docs/Web/Web_Components target=_blank>web components</a> or <a href=https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe target=_blank>iframes</a>, none of which are specific to microservices architectures.<p>Besides being only suitable for dashboard-style applications, other limiting factors for micro frontends include:<ul><li><em>Bounding context —</em> Micro-frontend solutions are typically only usable within a particular context rather than being universally applicable. This limiting context can be a particular organization (which precludes cross-organization applications), a particular web application, or a particular frontend framework such as React.js or Angular for example.<li><em>Data exchange —</em> The data exchange mechanism between a micro-frontend and its container is ad hoc at best. For example, if a micro-frontend is implemented as a React.js component, then the micro-frontend can use React.js's built-in mechanism for receiving data from its container. On the other hand, how and if a React.js component can return a result to its container is an implementation detail that needs to be resolved on a case by case basis. This is because micro frontends are conceived as UI components rather than full-blown services.<li id=nesting><em>Nesting —</em> Micro frontends typically cannot be nested beyond 1 or 2 levels, because the allocated screen area becomes significantly smaller with each nesting level.</ul></section><section><h3>Interactive microservices with Qworum</h3><p>Qworum is a UI technology that was made specifically for microservices architectures. In contrast to micro frontends, which are parts of web pages, Qworum takes the web-API approach to user interaction.<p id=interactive-service>In effect, Qworum defines a new type of web API where each end-point can receive data, interact with the end-user if needed, and then return a result. Note that Qworum services are not components embedded in web pages. Rather, they offer full-page UIs to end-users.<p>Also, in contrast to micro-frontend solutions where there are two types of entities (micro frontends and container applications), with Qworum everything is a Qworum service, including applications.<figure><img alt="With Qworum everything is a Qworum service, including applications"src=/assets/images/solution/ui-bottleneck-issue.svg><figcaption>With Qworum everything is a Qworum service, including applications</figcaption></figure><p>So, while Qworum complements micro frontends rather than making them obsolete, by the same token Qworum does not have many of the limitations that micro frontends are burdened with:<ul><li><em>Range of usage scenarios —</em> Qworum is a web-scale microservices platform that is usable both within organizations and across organizations. Qworum is also independent from any particular application or web framework.<li><em>Data exchange —</em> Qworum defines a standard mechanism for exchanging data between Qworum services and their callers. This obviates the need for developing ad hoc data exchange solutions that are specific to a given application, framework or organization.<li><em>Nesting —</em> Qworum allows for unbounded nesting levels.</ul><figure><img alt="Qworum allows for unbounded nesting levels"src=/assets/images/solution/bounded-nesting-issue.svg><figcaption>Qworum allows for unbounded nesting levels</figcaption></figure></section></section></main><footer><span class=footer-company> © <time datetime=2024> 2024 </time> Doğa Armangil </span> ・ <span> <a href=/docs/legal/terms-of-service/ target=_blank> Terms of service </a> ・ <a href=/docs/legal/privacy-policy/ target=_blank> Privacy policy </a> </span><br><span class=footer-hattip> Static site generated with <a href=https://lume.land target=_blank>Lume</a>. </span></footer>