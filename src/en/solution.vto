---
layout: layouts/base.vto
title: Solution
nav:
  order: 2
  selection: solution

---

<h1>
  Category-defining iPaaS and PaaS hybrid solution
</h1>

<p>
  Qworum offers a technology for modularizing the UI layer of web applications. This module system supports both single-origin and distributed multi-origin applications.
</p>
<p>
  In short, Qworum is a platform for composable architectures.
</p>
<p>
  And as soon as a module system can support distributed scenarios, it can be used for application integration as well.
  In other words, in distributed systems, integration and modularisation are two sides of the same coin.
  And that's why Qworum is both a PaaS and an iPaaS.
</p>
<figure>
  <img src="/assets/images/solution/qworum-ux.svg" alt="Qworum allows for unbounded nesting levels">
  <figcaption>The user experience of using Qworum applications</figcaption>
</figure>

<section id="integrations">
  <h2>Peerless iPaaS for integrating interactive processes</h2>
  <p>
    Qworum is the only platform able to support integrations involving complex dependency graphs. 
    Plus, Qworum makes simpler architectures 10x easier to implement.
  </p>
  <section id="user-authentication">
    <h3>
      A user authentication solution fit for even complex integrations
    </h3>
    <p>
      The simple fact of the matter is, without Qworum, the integration of interactive processes 
      involving deep dependencies between applications and services is a technical impossibility.
    </p>
    <p>
      For example, in the architecture outlined below, 
      how does <code>Application 1</code> authenticate the end-user for 
      <code>Service 2</code> and <code>Service 3</code>?
    </p>
    <figure>
      <img src="/assets/images/solution/user-authentication.svg" alt="Qworum allows for unbounded nesting levels">
      <figcaption>Qworum can handle user authentication in deep dependency graphs</figcaption>
    </figure>
    <p>
      In real-world settings such multi-tier integration scenarios will appear more and more often as new specialised
      SaaS offerings come online. Here is a plausible example:
    </p>
    <ul>
      <li>
        Application 1: A project management application such as Airtable, Monday.com, Zoho or Jira.
      </li>
      <li>
        Service 2: An artifact management service such as Confluence, Basecamp or SharePoint.
      </li>
      <li>
        Service 3: An messaging service such as Slack, Matrix or Microsoft Teams.
      </li>
    </ul>
    <p>
      Let's see what would happen without Qworum:
    </p>
    <ul>
      <li>
        Authenticating the user for <code>Service 2</code> is possible (because <code>Application 1</code> knows that <code>Service 2</code> must be used), although authenticating the user for a 3rd-party service is an overhead that is best avoided. But even for <code>Service 2</code> there is already a security problem, because now <code>Application 1</code> can impersonate the end-user on <code>Service 2</code>!
      </li>
      <li>
        It is fair to say that authenticating the user for <code>Service 3</code> is a technical impossibility.
        Indeed, <code>Application 1</code> doesn't even know that <code>Service 2</code> is using <code>Service 3</code> behind the scenes, not to mention all the conversation-tunnelling that must happen between the authenticating service and the end-user.
      </li>
    </ul>
    <p>
      For these reasons, today's composable architectures such as the MACH architecture only support one-level deep dependency trees, and they put on the main client application the burden of building all the UIs for all involved services.
    </p>
    <p>With Qworum all these limitations are removed:</p>
    <ul>
      <li>Each applications/service has direct access to the end-user and so can take care of authenticating their own end-users.</li>
      <li>
        Qworum preserves the confidentiality of user authentication information for all involved services.
      </li>
      <li>
        Qworum makes user-authentication a non-issue for all possible dependency-graph topologies.
      </li>
    </ul>
  </section>
  <section id="10x">
    <h3>10x easier integrations</h3>
    <p>
      Note that even for simple one-level dependency graphs,
      developing applications and services with Qworum is 10x easier than with other technologies, because:
    </p>
    <ul>
      <li>There is no need to authenticate the end-user for the called service.</li>
      <li>There is no need to obtain an API key for the called service.</li>
      <li>Calling Qworum APIs are much simpler than calling REST etc.</li>
    </ul>
  </section>

</section>

<section id="ui-bottleneck">
  <h2>Peerless PaaS for distributed applications</h2>

  <p>
    Qworum is the only platform that can support web applications that span multiple websites.
  </p>

  <section>
    <h3>What are microservices architectures?</h3>
    <p>
      Microservices architectures enable rapid software delivery by allowing different parts of a software system to
      be developed, deployed and updated in parallel by different teams within an organization and also across
      organizations.
    </p>
    <p>
      Microservices architectures organise developer teams around vertical slices of software systems rather than the
      horizontal UI, business logic, and data layers. In order words, microservice teams are responsible for all of
      these 3 layers within the boundaries of a particular slice.
    </p>
  </section>

  <section>
    <h3>What is wrong with monolithic user interfaces?</h3>
    <!-- <p>
      One problem that was unsolved until Qworum is the <em id="ui-monolith">UI monolith</em> issue for microservices architectures. 
    </p>
    <p>
      Indeed, without Qworum current microservices architectures are unable to slice the UI layer into microservices completely. Web applications still must have a monolithic component at the UI layer. This monolithic component acts as a container for the different  <a href="https://martinfowler.com/articles/micro frontends.html"
      target="_blank">micro frontends</a> which constitute parts of the monolith's web pages.
    </p> -->
    <p>
      For microservices architectures,
      having a monolithic component at the UI layer represents a bottleneck for the software development lifecycle,
      because the team responsible for the UI monolith cannot scale with the number of microservices.
    </p>

    <h3>Are micro frontends the right solution?</h3>
    <p>
      Today, the only solution that software developers have at their disposal for breaking UI monoliths into
      smaller parts involves micro frontends.
    </p>
    <p>
      Micro frontends are UI components that are plugged into dashboard-style web pages for building web
      applications. In this case web applications become simple containers for micro frontends.
    </p>
    <p>
      Micro frontends are implemented using various technologies such as <a
        href="https://reactjs.org/docs/components-and-props.html" target="_blank">React.js components</a>, <a
        href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" target="_blank">web components</a> or <a
        href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" target="_blank">iframes</a>, none of
      which are specific to microservices architectures.
    </p>
    <p>
      Besides being only suitable for dashboard-style applications, other limiting factors for micro frontends
      include:
    </p>
    <ul>
      <li>
        <em>Bounding context —</em>
        Micro-frontend solutions are typically only usable within a particular context rather than being universally
        applicable. This limiting context can be
        a particular organization (which precludes cross-organization applications),
        a particular web application, or
        a particular frontend framework such as React.js or Angular for example.
      </li>
      <li>
        <em>Data exchange —</em>
        The data exchange mechanism between a micro-frontend and its container is ad hoc at best.
        For example, if a micro-frontend is implemented as a React.js component, then the micro-frontend can use
        React.js's built-in mechanism for receiving data from its container.
        On the other hand, how and if a React.js component can return a result to its container is an implementation
        detail that needs to be resolved on a case by case basis.
        This is because micro frontends are conceived as UI components rather than full-blown services.
      </li>
      <li id="nesting">
        <em>Nesting —</em>
        Micro frontends typically cannot be nested beyond 1 or 2 levels, because the allocated screen area becomes
        significantly smaller with each nesting level.
      </li>
    </ul>
  </section>

  <section>
    <h3>Interactive microservices with Qworum</h3>
    <p>
      Qworum is a UI technology that was made specifically for microservices architectures.
      In contrast to micro frontends, which are parts of web pages,
      Qworum takes the web-API approach to user interaction.
    </p>
    <p id="interactive-service">
      In effect, Qworum defines a new type of web API where each end-point can receive data, interact with the
      end-user if needed, and then return a result. Note that Qworum services are not components embedded in web
      pages. Rather, they offer full-page UIs to end-users.
    </p>
    <p>
      Also, in contrast to micro-frontend solutions where there are two types of entities (micro frontends and
      container applications), with Qworum everything is a Qworum service, including applications.
    </p>
    <figure>
      <img src="/assets/images/solution/ui-bottleneck-issue.svg" alt="With Qworum everything is a Qworum service, including applications">
      <figcaption>With Qworum everything is a Qworum service, including applications</figcaption>
    </figure>
    <p>
      So, while Qworum complements micro frontends rather than making them obsolete, by the same token Qworum does
      not have many of the limitations that micro frontends are burdened with:
    </p>
    <ul>
      <li>
        <em>Range of usage scenarios —</em>
        Qworum is a web-scale microservices platform that is usable both within organizations and across
        organizations. Qworum is also independent from any particular application or web framework.
      </li>
      <li>
        <em>Data exchange —</em>
        Qworum defines a standard mechanism for exchanging data between Qworum services and their callers. This
        obviates the need for developing ad hoc data exchange solutions that are specific to a given application,
        framework or organization.
      </li>
      <li>
        <em>Nesting —</em>
        Qworum allows for unbounded nesting levels.
      </li>
    </ul>

    <figure>
      <img src="/assets/images/solution/bounded-nesting-issue.svg" alt="Qworum allows for unbounded nesting levels">
      <figcaption>Qworum allows for unbounded nesting levels</figcaption>
    </figure>
  </section>

</section>
